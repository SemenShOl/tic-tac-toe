"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/game/model/computingWinner.js":
/*!**************************************************!*\
  !*** ./components/game/model/computingWinner.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computingWinner: function() { return /* binding */ computingWinner; }\n/* harmony export */ });\nfunction computingWinner(cells, movedCellIndex, seqSize) {\n    //вычисляем rows (группы последовательностей длины выигрышной последовательности, различной формы - горизонтальные, вертикальные и тд., которые могут содержать выигрышыми )\n    const rows = computeRows(cells, {\n        x: movedCellIndex[0],\n        y: movedCellIndex[1]\n    }, seqSize);\n    //проходим по всем rows и проверяем равны ли в них символы\n    for(let i = 0; i < 4; i++){\n        const isEqual = areCellsInRowEqual(rows[i], cells, seqSize);\n        if (isEqual) return isEqual;\n    }\n}\nconst areCellsInRowEqual = (row, cells, seqSize)=>{\n    for(let i = 0; i < row.length; i++){\n        let isLineBreak = false; //флаг ответает за то, равны ли все символы в row[i], true - значит не равны\n        let answerRow = row[i]; //row, в которой все символы равны\n        for(let j = 1; j < seqSize; j++){\n            //row[i] - i-ый row, row[i][j] - j-ый вектор (координата символа) в i-ом row\n            //if проверяет равны ли символы в точках j и j-1 i-ого row и не равен ли символ в точке j нулю (j-1 проверять не требуется)\n            if (cells[row[i][j][0]][row[i][j][1]] !== cells[row[i][j - 1][0]][row[i][j - 1][1]] || !cells[row[i][j][0]][row[i][j][1]]) {\n                isLineBreak = true;\n                break;\n            }\n        }\n        if (!isLineBreak) return answerRow;\n    }\n    return false;\n};\nfunction computeRows(cells, movedCellIndex, seqSize) {\n    const line = cells[movedCellIndex.x].map((elem, index)=>index); //массив от 0 до ширины cells, определяет границы массива\n    const seqArray = new Array(seqSize).fill(null).map((elem, index)=>index); //массив чисел от 0 до seqSize-1 включительно\n    const rows = [\n        [],\n        [],\n        [],\n        []\n    ];\n    rows[0] = horizontal(movedCellIndex, seqSize, line);\n    rows[1] = vertical(movedCellIndex, seqSize, line);\n    rows[2] = obliquelyLeftToRight(movedCellIndex, seqSize, line, seqArray);\n    rows[3] = obliquelyRightToLeft(movedCellIndex, seqSize, line, seqArray);\n    return rows;\n}\nfunction horizontal(movedCellIndex, seqSize, line) {\n    // -\n    const row = [];\n    for(let i = 0; i < seqSize; i++){\n        const first = movedCellIndex.x - seqSize + i + 1;\n        const last = movedCellIndex.x + i;\n        //if проверяет находятся ли first(начало секвенции) и last(конец) внутри границ массива\n        if (line.includes(first) && line.includes(last)) row.push(line.slice(first, last + 1).map((elem)=>[\n                elem,\n                movedCellIndex.y\n            ]));\n    }\n    return row;\n}\nfunction vertical(movedCellIndex, seqSize, line) {\n    // |\n    const row = [];\n    for(let i = 0; i < seqSize; i++){\n        const first = movedCellIndex.y - seqSize + i + 1;\n        const last = movedCellIndex.y + i;\n        //if проверяет находятся ли first(начало секвенции) и last(конец) внутри границ массива\n        if (line.includes(first) && line.includes(last)) row.push(line.slice(first, last + 1).map((elem)=>[\n                movedCellIndex.x,\n                elem\n            ]));\n    }\n    return row;\n}\nfunction obliquelyLeftToRight(movedCellIndex, seqSize, line, seqArray) {\n    // /\n    const row = [];\n    for(let i = 0; i < seqSize; i++){\n        const first = {\n            x: movedCellIndex.x - seqSize + i + 1,\n            y: movedCellIndex.y - seqSize + i + 1\n        };\n        const last = {\n            x: movedCellIndex.x + i,\n            y: movedCellIndex.y + i\n        };\n        //if проверяет находятся ли координаты first(x-координата и y-координата) и last(x-координата и y-координата) внутри границ массива\n        if (line.includes(first.x) && line.includes(first.y) && line.includes(last.x) && line.includes(last.y)) //в row кладется точки вида [first.x,first.y], [first.x + 1,first.y + 1]..., инкримент прибавляет единицу\n        row.push(seqArray.map((increment)=>[\n                first.x + increment,\n                first.y + increment\n            ]));\n    }\n    return row;\n}\nfunction obliquelyRightToLeft(movedCellIndex, seqSize, line, seqArray) {\n    // \\\n    const row = [];\n    for(let i = 0; i < seqSize; i++){\n        const first = {\n            x: movedCellIndex.x + seqSize - i - 1,\n            y: movedCellIndex.y - seqSize + i + 1\n        };\n        const last = {\n            x: movedCellIndex.x - i,\n            y: movedCellIndex.y + i\n        };\n        //if проверяет находятся ли координаты first(x-координата и y-координата) и last(x-координата и y-координата) внутри границ массива\n        if (line.includes(first.x) && line.includes(first.y) && line.includes(last.x) && line.includes(last.y)) //в row кладется точки вида [first.x,first.y], [first.x + 1,first.y + 1]..., инкримент прибавляет единицу\n        row.push(seqArray.map((increment)=>[\n                first.x - increment,\n                first.y + increment\n            ]));\n    }\n    return row;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2dhbWUvbW9kZWwvY29tcHV0aW5nV2lubmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSxnQkFDZkMsS0FBSyxFQUNMQyxjQUFjLEVBQ2RDLE9BQU87SUFFUCw0S0FBNEs7SUFDNUssTUFBTUMsT0FBT0MsWUFDWkosT0FDQTtRQUNDSyxHQUFHSixjQUFjLENBQUMsRUFBRTtRQUNwQkssR0FBR0wsY0FBYyxDQUFDLEVBQUU7SUFDckIsR0FDQUM7SUFHRCwwREFBMEQ7SUFDMUQsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUMzQixNQUFNQyxVQUNMQyxtQkFDQ04sSUFBSSxDQUFDSSxFQUFFLEVBQ1BQLE9BQ0FFO1FBRUYsSUFBSU0sU0FBUyxPQUFPQTtJQUNyQjtBQUNEO0FBRUEsTUFBTUMscUJBQXFCLENBQzFCQyxLQUNBVixPQUNBRTtJQUVBLElBQ0MsSUFBSUssSUFBSSxHQUNSQSxJQUFJRyxJQUFJQyxNQUFNLEVBQ2RKLElBQ0M7UUFDRCxJQUFJSyxjQUFjLE9BQU8sNEVBQTRFO1FBQ3JHLElBQUlDLFlBQVlILEdBQUcsQ0FBQ0gsRUFBRSxFQUFFLGtDQUFrQztRQUMxRCxJQUNDLElBQUlPLElBQUksR0FDUkEsSUFBSVosU0FDSlksSUFDQztZQUNELDRFQUE0RTtZQUM1RSwySEFBMkg7WUFDM0gsSUFDQ2QsS0FBSyxDQUFDVSxHQUFHLENBQUNILEVBQUUsQ0FBQ08sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUNsQkosR0FBRyxDQUFDSCxFQUFFLENBQUNPLEVBQUUsQ0FBQyxFQUFFLENBQ1osS0FDQWQsS0FBSyxDQUFDVSxHQUFHLENBQUNILEVBQUUsQ0FBQ08sSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQ3RCSixHQUFHLENBQUNILEVBQUUsQ0FBQ08sSUFBSSxFQUFFLENBQUMsRUFBRSxDQUNoQixJQUNGLENBQUNkLEtBQUssQ0FBQ1UsR0FBRyxDQUFDSCxFQUFFLENBQUNPLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FDbkJKLEdBQUcsQ0FBQ0gsRUFBRSxDQUFDTyxFQUFFLENBQUMsRUFBRSxDQUNaLEVBQ0E7Z0JBQ0RGLGNBQWM7Z0JBQ2Q7WUFDRDtRQUNEO1FBRUEsSUFBSSxDQUFDQSxhQUNKLE9BQU9DO0lBQ1Q7SUFDQSxPQUFPO0FBQ1I7QUFFQSxTQUFTVCxZQUNSSixLQUFLLEVBQ0xDLGNBQWMsRUFDZEMsT0FBTztJQUVQLE1BQU1hLE9BQU9mLEtBQUssQ0FDakJDLGVBQWVJLENBQUMsQ0FDaEIsQ0FBQ1csR0FBRyxDQUFDLENBQUNDLE1BQU1DLFFBQVVBLFFBQVEseURBQXlEO0lBQ3hGLE1BQU1DLFdBQVcsSUFBSUMsTUFDcEJsQixTQUVDbUIsSUFBSSxDQUFDLE1BQ0xMLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQyxRQUFVQSxRQUFRLDZDQUE2QztJQUM1RSxNQUFNZixPQUFPO1FBQ1osRUFBRTtRQUNGLEVBQUU7UUFDRixFQUFFO1FBQ0YsRUFBRTtLQUNGO0lBQ0RBLElBQUksQ0FBQyxFQUFFLEdBQUdtQixXQUNUckIsZ0JBQ0FDLFNBQ0FhO0lBRURaLElBQUksQ0FBQyxFQUFFLEdBQUdvQixTQUNUdEIsZ0JBQ0FDLFNBQ0FhO0lBRURaLElBQUksQ0FBQyxFQUFFLEdBQUdxQixxQkFDVHZCLGdCQUNBQyxTQUNBYSxNQUNBSTtJQUVEaEIsSUFBSSxDQUFDLEVBQUUsR0FBR3NCLHFCQUNUeEIsZ0JBQ0FDLFNBQ0FhLE1BQ0FJO0lBRUQsT0FBT2hCO0FBQ1I7QUFFQSxTQUFTbUIsV0FDUnJCLGNBQWMsRUFDZEMsT0FBTyxFQUNQYSxJQUFJO0lBRUosSUFBSTtJQUNKLE1BQU1MLE1BQU0sRUFBRTtJQUVkLElBQ0MsSUFBSUgsSUFBSSxHQUNSQSxJQUFJTCxTQUNKSyxJQUNDO1FBQ0QsTUFBTW1CLFFBQ0x6QixlQUFlSSxDQUFDLEdBQ2hCSCxVQUNBSyxJQUNBO1FBQ0QsTUFBTW9CLE9BQ0wxQixlQUFlSSxDQUFDLEdBQUdFO1FBQ3BCLHVGQUF1RjtRQUN2RixJQUNDUSxLQUFLYSxRQUFRLENBQUNGLFVBQ2RYLEtBQUthLFFBQVEsQ0FBQ0QsT0FFZGpCLElBQUltQixJQUFJLENBQ1BkLEtBQ0VlLEtBQUssQ0FBQ0osT0FBT0MsT0FBTyxHQUNwQlgsR0FBRyxDQUFDQyxDQUFBQSxPQUFRO2dCQUNaQTtnQkFDQWhCLGVBQWVLLENBQUM7YUFDaEI7SUFFTDtJQUNBLE9BQU9JO0FBQ1I7QUFFQSxTQUFTYSxTQUNSdEIsY0FBYyxFQUNkQyxPQUFPLEVBQ1BhLElBQUk7SUFFSixJQUFJO0lBQ0osTUFBTUwsTUFBTSxFQUFFO0lBRWQsSUFDQyxJQUFJSCxJQUFJLEdBQ1JBLElBQUlMLFNBQ0pLLElBQ0M7UUFDRCxNQUFNbUIsUUFDTHpCLGVBQWVLLENBQUMsR0FDaEJKLFVBQ0FLLElBQ0E7UUFDRCxNQUFNb0IsT0FDTDFCLGVBQWVLLENBQUMsR0FBR0M7UUFDcEIsdUZBQXVGO1FBQ3ZGLElBQ0NRLEtBQUthLFFBQVEsQ0FBQ0YsVUFDZFgsS0FBS2EsUUFBUSxDQUFDRCxPQUVkakIsSUFBSW1CLElBQUksQ0FDUGQsS0FDRWUsS0FBSyxDQUFDSixPQUFPQyxPQUFPLEdBQ3BCWCxHQUFHLENBQUNDLENBQUFBLE9BQVE7Z0JBQ1poQixlQUFlSSxDQUFDO2dCQUNoQlk7YUFDQTtJQUVMO0lBQ0EsT0FBT1A7QUFDUjtBQUVBLFNBQVNjLHFCQUNSdkIsY0FBYyxFQUNkQyxPQUFPLEVBQ1BhLElBQUksRUFDSkksUUFBUTtJQUVSLElBQUk7SUFDSixNQUFNVCxNQUFNLEVBQUU7SUFFZCxJQUNDLElBQUlILElBQUksR0FDUkEsSUFBSUwsU0FDSkssSUFDQztRQUNELE1BQU1tQixRQUFRO1lBQ2JyQixHQUNDSixlQUFlSSxDQUFDLEdBQ2hCSCxVQUNBSyxJQUNBO1lBQ0RELEdBQ0NMLGVBQWVLLENBQUMsR0FDaEJKLFVBQ0FLLElBQ0E7UUFDRjtRQUNBLE1BQU1vQixPQUFPO1lBQ1p0QixHQUFHSixlQUFlSSxDQUFDLEdBQUdFO1lBQ3RCRCxHQUFHTCxlQUFlSyxDQUFDLEdBQUdDO1FBQ3ZCO1FBQ0EsbUlBQW1JO1FBQ25JLElBQ0NRLEtBQUthLFFBQVEsQ0FBQ0YsTUFBTXJCLENBQUMsS0FDckJVLEtBQUthLFFBQVEsQ0FBQ0YsTUFBTXBCLENBQUMsS0FDckJTLEtBQUthLFFBQVEsQ0FBQ0QsS0FBS3RCLENBQUMsS0FDcEJVLEtBQUthLFFBQVEsQ0FBQ0QsS0FBS3JCLENBQUMsR0FFcEIseUdBQXlHO1FBQ3pHSSxJQUFJbUIsSUFBSSxDQUNQVixTQUFTSCxHQUFHLENBQUNlLENBQUFBLFlBQWE7Z0JBQ3pCTCxNQUFNckIsQ0FBQyxHQUFHMEI7Z0JBQ1ZMLE1BQU1wQixDQUFDLEdBQUd5QjthQUNWO0lBRUo7SUFDQSxPQUFPckI7QUFDUjtBQUVBLFNBQVNlLHFCQUNSeEIsY0FBYyxFQUNkQyxPQUFPLEVBQ1BhLElBQUksRUFDSkksUUFBUTtJQUVSLElBQUk7SUFDSixNQUFNVCxNQUFNLEVBQUU7SUFFZCxJQUNDLElBQUlILElBQUksR0FDUkEsSUFBSUwsU0FDSkssSUFDQztRQUNELE1BQU1tQixRQUFRO1lBQ2JyQixHQUNDSixlQUFlSSxDQUFDLEdBQ2hCSCxVQUNBSyxJQUNBO1lBQ0RELEdBQ0NMLGVBQWVLLENBQUMsR0FDaEJKLFVBQ0FLLElBQ0E7UUFDRjtRQUNBLE1BQU1vQixPQUFPO1lBQ1p0QixHQUFHSixlQUFlSSxDQUFDLEdBQUdFO1lBQ3RCRCxHQUFHTCxlQUFlSyxDQUFDLEdBQUdDO1FBQ3ZCO1FBQ0EsbUlBQW1JO1FBQ25JLElBQ0NRLEtBQUthLFFBQVEsQ0FBQ0YsTUFBTXJCLENBQUMsS0FDckJVLEtBQUthLFFBQVEsQ0FBQ0YsTUFBTXBCLENBQUMsS0FDckJTLEtBQUthLFFBQVEsQ0FBQ0QsS0FBS3RCLENBQUMsS0FDcEJVLEtBQUthLFFBQVEsQ0FBQ0QsS0FBS3JCLENBQUMsR0FFcEIseUdBQXlHO1FBQ3pHSSxJQUFJbUIsSUFBSSxDQUNQVixTQUFTSCxHQUFHLENBQUNlLENBQUFBLFlBQWE7Z0JBQ3pCTCxNQUFNckIsQ0FBQyxHQUFHMEI7Z0JBQ1ZMLE1BQU1wQixDQUFDLEdBQUd5QjthQUNWO0lBRUo7SUFDQSxPQUFPckI7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2dhbWUvbW9kZWwvY29tcHV0aW5nV2lubmVyLmpzPzBjM2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGluZ1dpbm5lcihcclxuXHRjZWxscyxcclxuXHRtb3ZlZENlbGxJbmRleCxcclxuXHRzZXFTaXplLFxyXG4pIHtcclxuXHQvL9Cy0YvRh9C40YHQu9GP0LXQvCByb3dzICjQs9GA0YPQv9C/0Ysg0L/QvtGB0LvQtdC00L7QstCw0YLQtdC70YzQvdC+0YHRgtC10Lkg0LTQu9C40L3RiyDQstGL0LjQs9GA0YvRiNC90L7QuSDQv9C+0YHQu9C10LTQvtCy0LDRgtC10LvRjNC90L7RgdGC0LgsINGA0LDQt9C70LjRh9C90L7QuSDRhNC+0YDQvNGLIC0g0LPQvtGA0LjQt9C+0L3RgtCw0LvRjNC90YvQtSwg0LLQtdGA0YLQuNC60LDQu9GM0L3Ri9C1INC4INGC0LQuLCDQutC+0YLQvtGA0YvQtSDQvNC+0LPRg9GCINGB0L7QtNC10YDQttCw0YLRjCDQstGL0LjQs9GA0YvRiNGL0LzQuCApXHJcblx0Y29uc3Qgcm93cyA9IGNvbXB1dGVSb3dzKFxyXG5cdFx0Y2VsbHMsXHJcblx0XHR7XHJcblx0XHRcdHg6IG1vdmVkQ2VsbEluZGV4WzBdLFxyXG5cdFx0XHR5OiBtb3ZlZENlbGxJbmRleFsxXSxcclxuXHRcdH0sXHJcblx0XHRzZXFTaXplLFxyXG5cdCk7XHJcblxyXG5cdC8v0L/RgNC+0YXQvtC00LjQvCDQv9C+INCy0YHQtdC8IHJvd3Mg0Lgg0L/RgNC+0LLQtdGA0Y/QtdC8INGA0LDQstC90Ysg0LvQuCDQsiDQvdC40YUg0YHQuNC80LLQvtC70YtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG5cdFx0Y29uc3QgaXNFcXVhbCA9XHJcblx0XHRcdGFyZUNlbGxzSW5Sb3dFcXVhbChcclxuXHRcdFx0XHRyb3dzW2ldLFxyXG5cdFx0XHRcdGNlbGxzLFxyXG5cdFx0XHRcdHNlcVNpemUsXHJcblx0XHRcdCk7XHJcblx0XHRpZiAoaXNFcXVhbCkgcmV0dXJuIGlzRXF1YWw7XHJcblx0fVxyXG59XHJcblxyXG5jb25zdCBhcmVDZWxsc0luUm93RXF1YWwgPSAoXHJcblx0cm93LFxyXG5cdGNlbGxzLFxyXG5cdHNlcVNpemUsXHJcbikgPT4ge1xyXG5cdGZvciAoXHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRpIDwgcm93Lmxlbmd0aDtcclxuXHRcdGkrK1xyXG5cdCkge1xyXG5cdFx0bGV0IGlzTGluZUJyZWFrID0gZmFsc2U7IC8v0YTQu9Cw0LMg0L7RgtCy0LXRgtCw0LXRgiDQt9CwINGC0L4sINGA0LDQstC90Ysg0LvQuCDQstGB0LUg0YHQuNC80LLQvtC70Ysg0LIgcm93W2ldLCB0cnVlIC0g0LfQvdCw0YfQuNGCINC90LUg0YDQsNCy0L3Ri1xyXG5cdFx0bGV0IGFuc3dlclJvdyA9IHJvd1tpXTsgLy9yb3csINCyINC60L7RgtC+0YDQvtC5INCy0YHQtSDRgdC40LzQstC+0LvRiyDRgNCw0LLQvdGLXHJcblx0XHRmb3IgKFxyXG5cdFx0XHRsZXQgaiA9IDE7XHJcblx0XHRcdGogPCBzZXFTaXplO1xyXG5cdFx0XHRqKytcclxuXHRcdCkge1xyXG5cdFx0XHQvL3Jvd1tpXSAtIGkt0YvQuSByb3csIHJvd1tpXVtqXSAtIGot0YvQuSDQstC10LrRgtC+0YAgKNC60L7QvtGA0LTQuNC90LDRgtCwINGB0LjQvNCy0L7Qu9CwKSDQsiBpLdC+0Lwgcm93XHJcblx0XHRcdC8vaWYg0L/RgNC+0LLQtdGA0Y/QtdGCINGA0LDQstC90Ysg0LvQuCDRgdC40LzQstC+0LvRiyDQsiDRgtC+0YfQutCw0YUgaiDQuCBqLTEgaS3QvtCz0L4gcm93INC4INC90LUg0YDQsNCy0LXQvSDQu9C4INGB0LjQvNCy0L7QuyDQsiDRgtC+0YfQutC1IGog0L3Rg9C70Y4gKGotMSDQv9GA0L7QstC10YDRj9GC0Ywg0L3QtSDRgtGA0LXQsdGD0LXRgtGB0Y8pXHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRjZWxsc1tyb3dbaV1bal1bMF1dW1xyXG5cdFx0XHRcdFx0cm93W2ldW2pdWzFdXHJcblx0XHRcdFx0XSAhPT1cclxuXHRcdFx0XHRcdGNlbGxzW3Jvd1tpXVtqIC0gMV1bMF1dW1xyXG5cdFx0XHRcdFx0XHRyb3dbaV1baiAtIDFdWzFdXHJcblx0XHRcdFx0XHRdIHx8XHJcblx0XHRcdFx0IWNlbGxzW3Jvd1tpXVtqXVswXV1bXHJcblx0XHRcdFx0XHRyb3dbaV1bal1bMV1cclxuXHRcdFx0XHRdXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdGlzTGluZUJyZWFrID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghaXNMaW5lQnJlYWspXHJcblx0XHRcdHJldHVybiBhbnN3ZXJSb3c7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVSb3dzKFxyXG5cdGNlbGxzLFxyXG5cdG1vdmVkQ2VsbEluZGV4LFxyXG5cdHNlcVNpemUsXHJcbikge1xyXG5cdGNvbnN0IGxpbmUgPSBjZWxsc1tcclxuXHRcdG1vdmVkQ2VsbEluZGV4LnhcclxuXHRdLm1hcCgoZWxlbSwgaW5kZXgpID0+IGluZGV4KTsgLy/QvNCw0YHRgdC40LIg0L7RgiAwINC00L4g0YjQuNGA0LjQvdGLIGNlbGxzLCDQvtC/0YDQtdC00LXQu9GP0LXRgiDQs9GA0LDQvdC40YbRiyDQvNCw0YHRgdC40LLQsFxyXG5cdGNvbnN0IHNlcUFycmF5ID0gbmV3IEFycmF5KFxyXG5cdFx0c2VxU2l6ZSxcclxuXHQpXHJcblx0XHQuZmlsbChudWxsKVxyXG5cdFx0Lm1hcCgoZWxlbSwgaW5kZXgpID0+IGluZGV4KTsgLy/QvNCw0YHRgdC40LIg0YfQuNGB0LXQuyDQvtGCIDAg0LTQviBzZXFTaXplLTEg0LLQutC70Y7Rh9C40YLQtdC70YzQvdC+XHJcblx0Y29uc3Qgcm93cyA9IFtcclxuXHRcdFtdLCAvLyAtXHJcblx0XHRbXSwgLy8gfFxyXG5cdFx0W10sIC8vIC9cclxuXHRcdFtdLCAvLyBcXFxyXG5cdF07XHJcblx0cm93c1swXSA9IGhvcml6b250YWwoXHJcblx0XHRtb3ZlZENlbGxJbmRleCxcclxuXHRcdHNlcVNpemUsXHJcblx0XHRsaW5lLFxyXG5cdCk7XHJcblx0cm93c1sxXSA9IHZlcnRpY2FsKFxyXG5cdFx0bW92ZWRDZWxsSW5kZXgsXHJcblx0XHRzZXFTaXplLFxyXG5cdFx0bGluZSxcclxuXHQpO1xyXG5cdHJvd3NbMl0gPSBvYmxpcXVlbHlMZWZ0VG9SaWdodChcclxuXHRcdG1vdmVkQ2VsbEluZGV4LFxyXG5cdFx0c2VxU2l6ZSxcclxuXHRcdGxpbmUsXHJcblx0XHRzZXFBcnJheSxcclxuXHQpO1xyXG5cdHJvd3NbM10gPSBvYmxpcXVlbHlSaWdodFRvTGVmdChcclxuXHRcdG1vdmVkQ2VsbEluZGV4LFxyXG5cdFx0c2VxU2l6ZSxcclxuXHRcdGxpbmUsXHJcblx0XHRzZXFBcnJheSxcclxuXHQpO1xyXG5cdHJldHVybiByb3dzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBob3Jpem9udGFsKFxyXG5cdG1vdmVkQ2VsbEluZGV4LFxyXG5cdHNlcVNpemUsXHJcblx0bGluZSxcclxuKSB7XHJcblx0Ly8gLVxyXG5cdGNvbnN0IHJvdyA9IFtdO1xyXG5cclxuXHRmb3IgKFxyXG5cdFx0bGV0IGkgPSAwO1xyXG5cdFx0aSA8IHNlcVNpemU7XHJcblx0XHRpKytcclxuXHQpIHtcclxuXHRcdGNvbnN0IGZpcnN0ID1cclxuXHRcdFx0bW92ZWRDZWxsSW5kZXgueCAtXHJcblx0XHRcdHNlcVNpemUgK1xyXG5cdFx0XHRpICtcclxuXHRcdFx0MTtcclxuXHRcdGNvbnN0IGxhc3QgPVxyXG5cdFx0XHRtb3ZlZENlbGxJbmRleC54ICsgaTtcclxuXHRcdC8vaWYg0L/RgNC+0LLQtdGA0Y/QtdGCINC90LDRhdC+0LTRj9GC0YHRjyDQu9C4IGZpcnN0KNC90LDRh9Cw0LvQviDRgdC10LrQstC10L3RhtC40LgpINC4IGxhc3Qo0LrQvtC90LXRhikg0LLQvdGD0YLRgNC4INCz0YDQsNC90LjRhiDQvNCw0YHRgdC40LLQsFxyXG5cdFx0aWYgKFxyXG5cdFx0XHRsaW5lLmluY2x1ZGVzKGZpcnN0KSAmJlxyXG5cdFx0XHRsaW5lLmluY2x1ZGVzKGxhc3QpXHJcblx0XHQpXHJcblx0XHRcdHJvdy5wdXNoKFxyXG5cdFx0XHRcdGxpbmVcclxuXHRcdFx0XHRcdC5zbGljZShmaXJzdCwgbGFzdCArIDEpXHJcblx0XHRcdFx0XHQubWFwKGVsZW0gPT4gW1xyXG5cdFx0XHRcdFx0XHRlbGVtLFxyXG5cdFx0XHRcdFx0XHRtb3ZlZENlbGxJbmRleC55LFxyXG5cdFx0XHRcdFx0XSksXHJcblx0XHRcdCk7XHJcblx0fVxyXG5cdHJldHVybiByb3c7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZlcnRpY2FsKFxyXG5cdG1vdmVkQ2VsbEluZGV4LFxyXG5cdHNlcVNpemUsXHJcblx0bGluZSxcclxuKSB7XHJcblx0Ly8gfFxyXG5cdGNvbnN0IHJvdyA9IFtdO1xyXG5cclxuXHRmb3IgKFxyXG5cdFx0bGV0IGkgPSAwO1xyXG5cdFx0aSA8IHNlcVNpemU7XHJcblx0XHRpKytcclxuXHQpIHtcclxuXHRcdGNvbnN0IGZpcnN0ID1cclxuXHRcdFx0bW92ZWRDZWxsSW5kZXgueSAtXHJcblx0XHRcdHNlcVNpemUgK1xyXG5cdFx0XHRpICtcclxuXHRcdFx0MTtcclxuXHRcdGNvbnN0IGxhc3QgPVxyXG5cdFx0XHRtb3ZlZENlbGxJbmRleC55ICsgaTtcclxuXHRcdC8vaWYg0L/RgNC+0LLQtdGA0Y/QtdGCINC90LDRhdC+0LTRj9GC0YHRjyDQu9C4IGZpcnN0KNC90LDRh9Cw0LvQviDRgdC10LrQstC10L3RhtC40LgpINC4IGxhc3Qo0LrQvtC90LXRhikg0LLQvdGD0YLRgNC4INCz0YDQsNC90LjRhiDQvNCw0YHRgdC40LLQsFxyXG5cdFx0aWYgKFxyXG5cdFx0XHRsaW5lLmluY2x1ZGVzKGZpcnN0KSAmJlxyXG5cdFx0XHRsaW5lLmluY2x1ZGVzKGxhc3QpXHJcblx0XHQpXHJcblx0XHRcdHJvdy5wdXNoKFxyXG5cdFx0XHRcdGxpbmVcclxuXHRcdFx0XHRcdC5zbGljZShmaXJzdCwgbGFzdCArIDEpXHJcblx0XHRcdFx0XHQubWFwKGVsZW0gPT4gW1xyXG5cdFx0XHRcdFx0XHRtb3ZlZENlbGxJbmRleC54LFxyXG5cdFx0XHRcdFx0XHRlbGVtLFxyXG5cdFx0XHRcdFx0XSksXHJcblx0XHRcdCk7XHJcblx0fVxyXG5cdHJldHVybiByb3c7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9ibGlxdWVseUxlZnRUb1JpZ2h0KFxyXG5cdG1vdmVkQ2VsbEluZGV4LFxyXG5cdHNlcVNpemUsXHJcblx0bGluZSxcclxuXHRzZXFBcnJheSxcclxuKSB7XHJcblx0Ly8gL1xyXG5cdGNvbnN0IHJvdyA9IFtdO1xyXG5cclxuXHRmb3IgKFxyXG5cdFx0bGV0IGkgPSAwO1xyXG5cdFx0aSA8IHNlcVNpemU7XHJcblx0XHRpKytcclxuXHQpIHtcclxuXHRcdGNvbnN0IGZpcnN0ID0ge1xyXG5cdFx0XHR4OlxyXG5cdFx0XHRcdG1vdmVkQ2VsbEluZGV4LnggLVxyXG5cdFx0XHRcdHNlcVNpemUgK1xyXG5cdFx0XHRcdGkgK1xyXG5cdFx0XHRcdDEsXHJcblx0XHRcdHk6XHJcblx0XHRcdFx0bW92ZWRDZWxsSW5kZXgueSAtXHJcblx0XHRcdFx0c2VxU2l6ZSArXHJcblx0XHRcdFx0aSArXHJcblx0XHRcdFx0MSxcclxuXHRcdH07XHJcblx0XHRjb25zdCBsYXN0ID0ge1xyXG5cdFx0XHR4OiBtb3ZlZENlbGxJbmRleC54ICsgaSxcclxuXHRcdFx0eTogbW92ZWRDZWxsSW5kZXgueSArIGksXHJcblx0XHR9O1xyXG5cdFx0Ly9pZiDQv9GA0L7QstC10YDRj9C10YIg0L3QsNGF0L7QtNGP0YLRgdGPINC70Lgg0LrQvtC+0YDQtNC40L3QsNGC0YsgZmlyc3QoeC3QutC+0L7RgNC00LjQvdCw0YLQsCDQuCB5LdC60L7QvtGA0LTQuNC90LDRgtCwKSDQuCBsYXN0KHgt0LrQvtC+0YDQtNC40L3QsNGC0LAg0LggeS3QutC+0L7RgNC00LjQvdCw0YLQsCkg0LLQvdGD0YLRgNC4INCz0YDQsNC90LjRhiDQvNCw0YHRgdC40LLQsFxyXG5cdFx0aWYgKFxyXG5cdFx0XHRsaW5lLmluY2x1ZGVzKGZpcnN0LngpICYmXHJcblx0XHRcdGxpbmUuaW5jbHVkZXMoZmlyc3QueSkgJiZcclxuXHRcdFx0bGluZS5pbmNsdWRlcyhsYXN0LngpICYmXHJcblx0XHRcdGxpbmUuaW5jbHVkZXMobGFzdC55KVxyXG5cdFx0KVxyXG5cdFx0XHQvL9CyIHJvdyDQutC70LDQtNC10YLRgdGPINGC0L7Rh9C60Lgg0LLQuNC00LAgW2ZpcnN0LngsZmlyc3QueV0sIFtmaXJzdC54ICsgMSxmaXJzdC55ICsgMV0uLi4sINC40L3QutGA0LjQvNC10L3RgiDQv9GA0LjQsdCw0LLQu9GP0LXRgiDQtdC00LjQvdC40YbRg1xyXG5cdFx0XHRyb3cucHVzaChcclxuXHRcdFx0XHRzZXFBcnJheS5tYXAoaW5jcmVtZW50ID0+IFtcclxuXHRcdFx0XHRcdGZpcnN0LnggKyBpbmNyZW1lbnQsXHJcblx0XHRcdFx0XHRmaXJzdC55ICsgaW5jcmVtZW50LFxyXG5cdFx0XHRcdF0pLFxyXG5cdFx0XHQpO1xyXG5cdH1cclxuXHRyZXR1cm4gcm93O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYmxpcXVlbHlSaWdodFRvTGVmdChcclxuXHRtb3ZlZENlbGxJbmRleCxcclxuXHRzZXFTaXplLFxyXG5cdGxpbmUsXHJcblx0c2VxQXJyYXksXHJcbikge1xyXG5cdC8vIFxcXHJcblx0Y29uc3Qgcm93ID0gW107XHJcblxyXG5cdGZvciAoXHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRpIDwgc2VxU2l6ZTtcclxuXHRcdGkrK1xyXG5cdCkge1xyXG5cdFx0Y29uc3QgZmlyc3QgPSB7XHJcblx0XHRcdHg6XHJcblx0XHRcdFx0bW92ZWRDZWxsSW5kZXgueCArXHJcblx0XHRcdFx0c2VxU2l6ZSAtXHJcblx0XHRcdFx0aSAtXHJcblx0XHRcdFx0MSxcclxuXHRcdFx0eTpcclxuXHRcdFx0XHRtb3ZlZENlbGxJbmRleC55IC1cclxuXHRcdFx0XHRzZXFTaXplICtcclxuXHRcdFx0XHRpICtcclxuXHRcdFx0XHQxLFxyXG5cdFx0fTtcclxuXHRcdGNvbnN0IGxhc3QgPSB7XHJcblx0XHRcdHg6IG1vdmVkQ2VsbEluZGV4LnggLSBpLFxyXG5cdFx0XHR5OiBtb3ZlZENlbGxJbmRleC55ICsgaSxcclxuXHRcdH07XHJcblx0XHQvL2lmINC/0YDQvtCy0LXRgNGP0LXRgiDQvdCw0YXQvtC00Y/RgtGB0Y8g0LvQuCDQutC+0L7RgNC00LjQvdCw0YLRiyBmaXJzdCh4LdC60L7QvtGA0LTQuNC90LDRgtCwINC4IHkt0LrQvtC+0YDQtNC40L3QsNGC0LApINC4IGxhc3QoeC3QutC+0L7RgNC00LjQvdCw0YLQsCDQuCB5LdC60L7QvtGA0LTQuNC90LDRgtCwKSDQstC90YPRgtGA0Lgg0LPRgNCw0L3QuNGGINC80LDRgdGB0LjQstCwXHJcblx0XHRpZiAoXHJcblx0XHRcdGxpbmUuaW5jbHVkZXMoZmlyc3QueCkgJiZcclxuXHRcdFx0bGluZS5pbmNsdWRlcyhmaXJzdC55KSAmJlxyXG5cdFx0XHRsaW5lLmluY2x1ZGVzKGxhc3QueCkgJiZcclxuXHRcdFx0bGluZS5pbmNsdWRlcyhsYXN0LnkpXHJcblx0XHQpXHJcblx0XHRcdC8v0LIgcm93INC60LvQsNC00LXRgtGB0Y8g0YLQvtGH0LrQuCDQstC40LTQsCBbZmlyc3QueCxmaXJzdC55XSwgW2ZpcnN0LnggKyAxLGZpcnN0LnkgKyAxXS4uLiwg0LjQvdC60YDQuNC80LXQvdGCINC/0YDQuNCx0LDQstC70Y/QtdGCINC10LTQuNC90LjRhtGDXHJcblx0XHRcdHJvdy5wdXNoKFxyXG5cdFx0XHRcdHNlcUFycmF5Lm1hcChpbmNyZW1lbnQgPT4gW1xyXG5cdFx0XHRcdFx0Zmlyc3QueCAtIGluY3JlbWVudCxcclxuXHRcdFx0XHRcdGZpcnN0LnkgKyBpbmNyZW1lbnQsXHJcblx0XHRcdFx0XSksXHJcblx0XHRcdCk7XHJcblx0fVxyXG5cdHJldHVybiByb3c7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNvbXB1dGluZ1dpbm5lciIsImNlbGxzIiwibW92ZWRDZWxsSW5kZXgiLCJzZXFTaXplIiwicm93cyIsImNvbXB1dGVSb3dzIiwieCIsInkiLCJpIiwiaXNFcXVhbCIsImFyZUNlbGxzSW5Sb3dFcXVhbCIsInJvdyIsImxlbmd0aCIsImlzTGluZUJyZWFrIiwiYW5zd2VyUm93IiwiaiIsImxpbmUiLCJtYXAiLCJlbGVtIiwiaW5kZXgiLCJzZXFBcnJheSIsIkFycmF5IiwiZmlsbCIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsIm9ibGlxdWVseUxlZnRUb1JpZ2h0Iiwib2JsaXF1ZWx5UmlnaHRUb0xlZnQiLCJmaXJzdCIsImxhc3QiLCJpbmNsdWRlcyIsInB1c2giLCJzbGljZSIsImluY3JlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/game/model/computingWinner.js\n"));

/***/ })

});